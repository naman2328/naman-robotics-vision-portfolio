<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Industrial Vision Simulator</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="https://unpkg.com/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
</head>
<body>

<div class="container">
  <a href="index.html" class="sticky-back-btn">← Back to Home</a>

  <span class="badge">Inspection Simulator</span>
  <h1>Industrial Vision Dashboard (Web Simulator)</h1>

  <div class="section card">
    <p class="simulator-note">
      ⚠️ <b>Important:</b> This browser simulator demonstrates workflow and decision logic.
      The production system runs as a Qt application with PaddleOCR, barcode decoding,
      and industrial cameras.
    </p>
  </div>

  <div class="section grid">
    <div class="card">
      <h2>Camera Feed (Webcam)</h2>
      <div class="video-wrap">
        <video id="video" class="video-feed" autoplay muted playsinline></video>
        <canvas id="overlay" class="overlay-canvas"></canvas>
      </div>
      <p style="margin-top:8px;">Click and drag to define ROI.</p>
    </div>

    <div class="card">
      <h2>Inspection Status</h2>
      <div class="status-list">
        <p><span>System</span> <span id="systemStatus" class="ok">READY</span></p>
        <p><span>Detected Text</span> <span id="ocrText">---</span></p>
        <p><span>Result</span> <span id="resultText">---</span></p>
        <p><span>Confidence</span> <span id="confidence">---</span></p>
        <p><span>Cycle Time</span> <span id="cycleTime">---</span></p>
      </div>

      <div class="action-row">
        <button id="runOcrBtn" class="button" type="button">Single Capture</button>
        <button id="clearLogsBtn" class="button ghost" type="button">Clear Logs</button>
      </div>
    </div>
  </div>

  <div class="section card">
    <h2>System Logs</h2>
    <div id="logs" class="logs-panel" aria-live="polite"></div>
  </div>

  <div class="section card">
    <h2>Inspection Logic (Mirrored)</h2>
    <p>
      OCR → text normalization → fuzzy matching → OK / NG decision → confidence & timing → logging.
      This simulator mirrors production decision flow while using web-compatible OCR.
    </p>
  </div>
</div>

<script>
const expectedEntries = ["ABC123", "LOT45"];
const MATCH_THRESHOLD = 0.78;

let roi = null;
let drawing = false;
let startX = 0;
let startY = 0;

const video = document.getElementById("video");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");

const systemStatus = document.getElementById("systemStatus");
const ocrTextEl = document.getElementById("ocrText");
const resultText = document.getElementById("resultText");
const confidenceEl = document.getElementById("confidence");
const cycleTimeEl = document.getElementById("cycleTime");
const logs = document.getElementById("logs");
const runOcrBtn = document.getElementById("runOcrBtn");
const clearLogsBtn = document.getElementById("clearLogsBtn");

navigator.mediaDevices.getUserMedia({ video: true })
  .then(stream => {
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      log("Webcam stream started");
    };
  })
  .catch(error => {
    systemStatus.textContent = "CAMERA ERROR";
    systemStatus.className = "fail";
    log(`Camera access failed: ${error.message}`);
  });

canvas.addEventListener("mousedown", e => {
  drawing = true;
  startX = e.offsetX;
  startY = e.offsetY;
});

canvas.addEventListener("mousemove", e => {
  if (!drawing) return;
  draw();
  drawRect(startX, startY, e.offsetX - startX, e.offsetY - startY, "#facc15");
});

canvas.addEventListener("mouseup", e => {
  drawing = false;
  const width = Math.abs(e.offsetX - startX);
  const height = Math.abs(e.offsetY - startY);

  if (width < 20 || height < 20) {
    roi = null;
    draw();
    log("ROI too small. Please select a larger area.");
    return;
  }

  roi = {
    x: Math.min(startX, e.offsetX),
    y: Math.min(startY, e.offsetY),
    w: width,
    h: height
  };

  log(`ROI defined (${Math.round(roi.w)}x${Math.round(roi.h)})`);
  draw();
});

runOcrBtn.addEventListener("click", runOCR);
clearLogsBtn.addEventListener("click", () => {
  logs.textContent = "";
  log("Logs cleared");
});

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (roi) drawRect(roi.x, roi.y, roi.w, roi.h, "#22c55e");
}

function drawRect(x, y, w, h, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
}

function normalize(text) {
  return text.toLowerCase().replace(/[^a-z0-9]/g, "");
}

function levenshtein(a, b) {
  if (a === b) return 0;
  if (!a.length) return b.length;
  if (!b.length) return a.length;

  const dp = Array.from({ length: a.length + 1 }, () => new Array(b.length + 1).fill(0));

  for (let i = 0; i <= a.length; i++) dp[i][0] = i;
  for (let j = 0; j <= b.length; j++) dp[0][j] = j;

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + cost
      );
    }
  }

  return dp[a.length][b.length];
}

function similarityScore(a, b) {
  const maxLen = Math.max(a.length, b.length);
  if (!maxLen) return 1;
  return 1 - (levenshtein(a, b) / maxLen);
}

function isMatch(expected, detectedWords) {
  const normalizedExpected = normalize(expected);
  const joined = normalize(detectedWords.join(""));

  const candidateScores = detectedWords
    .map(word => similarityScore(normalizedExpected, normalize(word)))
    .concat(similarityScore(normalizedExpected, joined));

  return Math.max(...candidateScores) >= MATCH_THRESHOLD;
}

async function runOCR() {
  if (!roi) {
    alert("Define ROI first.");
    return;
  }

  const t0 = performance.now();
  runOcrBtn.disabled = true;
  systemStatus.textContent = "PROCESSING";
  systemStatus.className = "";
  log("OCR cycle started");

  try {
    const temp = document.createElement("canvas");
    temp.width = roi.w;
    temp.height = roi.h;

    temp.getContext("2d").drawImage(
      video,
      roi.x, roi.y, roi.w, roi.h,
      0, 0, roi.w, roi.h
    );

    const result = await Tesseract.recognize(temp, "eng");
    const words = result.data.words.map(w => w.text).filter(Boolean);

    ocrTextEl.textContent = words.join(" | ") || "(no text)";
    confidenceEl.textContent = `${result.data.confidence.toFixed(1)}%`;

    const matched = expectedEntries.filter(entry => isMatch(entry, words));
    const status = matched.length === expectedEntries.length ? "OK" : "NG";

    resultText.textContent = status;
    resultText.className = status === "OK" ? "ok" : "fail";
    log(`OCR completed → ${status} (matched ${matched.length}/${expectedEntries.length})`);
  } catch (error) {
    resultText.textContent = "ERROR";
    resultText.className = "fail";
    confidenceEl.textContent = "---";
    log(`OCR failed: ${error.message}`);
  } finally {
    cycleTimeEl.textContent = `${((performance.now() - t0) / 1000).toFixed(2)} s`;
    systemStatus.textContent = "READY";
    systemStatus.className = "ok";
    runOcrBtn.disabled = false;
  }
}

function log(message) {
  const line = document.createElement("div");
  line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
  logs.appendChild(line);
  logs.scrollTop = logs.scrollHeight;
}
</script>

</body>
</html>
